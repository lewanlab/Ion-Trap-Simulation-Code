%% Verify Equilibrium Separation of Ions in a Linear Chain
% Author: Elliot Bentine 2013
clear all
close all

% This script verifies the correct equilibrium separations for ions in a
% linear Paul trap, simulated in NAMD. We compare to the paper 'Quantum
% dynamics of cold trapped ions with application to quantum computation' by
% D.F.V. James throughout.

% Trap parameters are defined below.
Trapfrequency = 3.85e6; %Hz
TrapQ = 0.3;
TrapA = -0.001;
R0 = (7e-3)/2; %m
EndcapZ0 = (5.5e-3)/2; %m
geometricC = 0.244;

% Simulation results will be stored in the result and output folders.
f = java.io.File('output');
if ~f.exists()
    mkdir('output');
end

f = java.io.File('result');
if ~f.exists()
    mkdir('result');
end

% We iterate through a for loop of the number of ions. For each, we perform
% a simulation with sufficient time for the crystal to cool, then measure
% the atomic separations.

NumberOfIons = 1:10;
results = struct('N', {}, 'positions', {});

for i=1:length(NumberOfIons)
    close all;

    ionMass = 40; %amu
    ionCharge = +1; % electron charges
    
    q_z = 0;
    a_z = -2*TrapA;
    theoreticalZFreq = Trapfrequency/2*sqrt((q_z^2)/2 + a_z);
    axialAngularFreq = 2*pi*theoreticalZFreq;
    lengthScale = (((ionCharge * 1.6e-19) .^2)/(4*pi*8.85e-12)/(ionMass * 1.661e-27 *(axialAngularFreq.^2))).^(1/3);
    
    % We create a simulation in LAMMPS using the Matlab Wrapper. We have
    % used a stronger damping than would typically be measured in
    % experiment for the Langevin bath in order that the series of
    % simulations may be completed in reasonable time.
    sim = LAMMPSSimulation();
    
    SetSimulationDomain(sim, 1e-3,1e-3,1e-3);
    ions = sim.AddAtomType(ionCharge, ionMass);
    [oscV, endcapV] = getVs4aq(ions, Trapfrequency, EndcapZ0, R0, geometricC, TrapA, TrapQ);
    createIonCloud(sim, 1e-3, ions, NumberOfIons(i), 1e-4);
    sim.Add(linearPT(oscV, endcapV, EndcapZ0, R0, geometricC, Trapfrequency));
    sim.Add(langevinBath(0, 2e-5));
    
    %Configure output to a file
    sim.Add(dump('positions.txt', {'id', 'x', 'y', 'z'}, 10));
    
    % Run simulation
    sim.Add(evolve(40000));
    sim.Execute();
    
    % Output trajectories are loaded from the DCD file generated by LAMMPS
    % into Matlab for analysis:
    [timesteps, ~, x,y,z] = readDump('positions.txt');
    
    x=x';
    y=y';
    z=z';
    
    time = timesteps*sim.TimeStep;
    
    % If we had theoretical positions (taken from aforementioned paper) for
    % this number of ions, then construct a graph to test results agree:
    [theoreticalPos, success] = getTheoreticalPosition(NumberOfIons(i),lengthScale);
    
    if success
        
        theoreticalPos = theoreticalPos * 1e3; %convert m to mm, the scale of the graph
        duration = max(time)-min(time);
        theoreticalT = [max(time) max(time)+0.1*duration]; %x-axis points at which to plot theoretical results (to append them to the graph after simulation results)
        
        % Plot a graph of z-positions of each ion.
        zPosFig = figure('Position', [100, 100, 1400, 600]);
        subplot(1,3,[1 2]);
        cc=hsv(NumberOfIons(i));
        hold on;
        for j=1:NumberOfIons(i)
            plot(time, z(:,j)*1e3, 'color', cc(j,:));
            v = plot(theoreticalT, [theoreticalPos(j) theoreticalPos(j)], ':k');
        end
        title('Z-axis trajectory of ions in the trap');
        xlabel('time (s)');
        ylabel('Z-position (mm)');
        
        legend(v, 'theoretical positions');
        
        %draw a zoomed-in version for ease of checking.
        subplot(1,3,3);
        hold on
        for j=1:NumberOfIons(i)
            plot(time, z(:,j)*1e3, 'color', cc(j,:));
            v = plot(theoreticalT, [theoreticalPos(j) theoreticalPos(j)], ':k');
        end
        
        %configure axes
        xlim([max(time)-0.04*duration max(time)+0.04*duration]);
        
        %title
        title('Magnification of Final Positions (for Ease of Comparison)');
        xlabel('time (s)');
        ylabel('Z-position (mm)');
        
        results(end+1) = struct('N', i, 'positions', z(end, :));
        
        print(zPosFig, '-dpdf', fullfile('output',sprintf('%dionsZpos.pdf', NumberOfIons(i)))); 
    end
    
    % We also generate graphs of radial positions, so we may check to
    % ensure that the generated ion crystal is a linear ion chain.
    radialFig = figure;
    hold on;
    for j=1:NumberOfIons(i)
        plot(time, ((y(:,j).^2+x(:,j).^2).^0.5)*1e3, 'color', cc(j,:));
    end
    title('Radial trajectory of ions in the trap');
    xlabel('time (s)');
    ylabel('Radial position (mm)');
    print(radialFig, '-dpdf', fullfile('output',sprintf('%dionsRpos.pdf', NumberOfIons(i)))); 
    
    close all
end

save('results.mat', 'results', 'lengthScale');